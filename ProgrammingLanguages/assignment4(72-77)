/*72*/

|- let rec f = fun x -> if x < 1 then [] else x :: f (x - 1) in f 3 evalto 3 :: 2 :: 1 :: [] by E-LetRec {
    f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)] |- f 3 evalto 3 :: 2 :: 1 :: [] by E-AppRec {
        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)] |- f evalto ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)] by E-Var {};
        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)] |- 3 evalto 3 by E-Int {};
        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- if x < 1 then [] else x :: f (x - 1) evalto 3 :: 2 :: 1 :: [] by E-IfF {
            f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- x < 1 evalto false by E-Lt {
                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- x evalto 3 by E-Var {};
                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- 1 evalto 1 by E-Int {};
                3 less than 1 is false by B-Lt {}
            };
            f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- x :: f (x - 1) evalto 3 :: 2 :: 1 :: [] by E-Cons {
                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- x evalto 3 by E-Var {};
                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- f (x - 1) evalto 2 :: 1 :: [] by E-AppRec {
                    f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- f evalto ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)] by E-Var {};
                    f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- x - 1 evalto 2 by E-Minus {
                        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- x evalto 3 by E-Var {};
                        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 3 |- 1 evalto 1 by E-Int {};
                        3 minus 1 is 2 by B-Minus {}
                    };
                    f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- if x < 1 then [] else x :: f (x - 1) evalto 2 :: 1 :: [] by E-IfF {
                        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- x < 1 evalto false by E-Lt {
                            f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- x evalto 2 by E-Var {};
                                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- 1 evalto 1 by E-Int {};
                                2 less than 1 is false by B-Lt {}
                        };
                        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- x :: f (x - 1) evalto 2 :: 1 :: [] by E-Cons {
                            f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- x evalto 2 by E-Var {};
                            f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- f (x - 1) evalto 1 :: [] by E-AppRec {
                                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- f evalto ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)] by E-Var {};
                                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- x - 1 evalto 1 by E-Minus {
                                    f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- x evalto 2 by E-Var {};
                                    f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 2 |- 1 evalto 1 by E-Int {};
                                    2 minus 1 is 1 by B-Minus {}
                                };
                                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- if x < 1 then [] else x :: f (x - 1) evalto 1 :: [] by E-IfF {
                                    f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- x < 1 evalto false by E-Lt {
                                        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- x evalto 1 by E-Var {};
                                        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- 1 evalto 1 by E-Int {};
                                        1 less than 1 is false by B-Lt {}
                                    };
                                    f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- x :: f (x - 1) evalto 1 :: [] by E-Cons {
                                        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- x evalto 1 by E-Var {};
                                        f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- f (x - 1) evalto [] by E-AppRec {
                                            f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- f evalto ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)] by E-Var {};
                                            f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- x - 1 evalto 0 by E-Minus {
                                                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- x evalto 1 by E-Var {};
                                                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 1 |- 1 evalto 1 by E-Int {};
                                                1 minus 1 is 0 by B-Minus {}
                                            };
                                            f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 0 |- if x < 1 then [] else x :: f (x - 1) evalto [] by E-IfT {
                                                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 0 |- x < 1 evalto true by E-Lt {
                                                    f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 0 |- x evalto 0 by E-Var {};
                                                    f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 0 |- 1 evalto 1 by E-Int {};
                                                    0 is less than 1 by B-Lt {}
                                                };
                                                f = ()[rec f = fun x -> if x < 1 then [] else x :: f (x - 1)], x = 0 |- [] evalto [] by E-Nil {}
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/*73*/ 函数length的意义很明显，是求list的长度，每一次recursion是x吃掉一个list的长度，然后1+增加1。LetRec分为两部分，一部分是吃list，一部分是加长度，中间的纽带是环境变量。
|- let rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y in length (1 :: 2 :: 3 :: []) evalto 3 by E-LetRec {
    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- length (1 :: 2 :: 3 :: []) evalto 3 by E-AppRec {
        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- length evalto ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] by E-Var {};
        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 1::2::3::[] evalto 1::2::3::[] by E-Cons {
            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 1 evalto 1 by E-Int {};
            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 2::3::[] evalto 2::3::[] by E-Cons {
                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 2 evalto 2 by E-Int {};
                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 3::[] evalto 3::[] by E-Cons {
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 3 evalto 3 by E-Int {};
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- [] evalto [] by E-Nil {};
                };
            };
        };
        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 1::2::3::[] |- match l with [] -> 0 | x :: y -> 1 + length y evalto 3 by E-MatchCons {
            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 1::2::3::[] |- l evalto 1::2::3::[] by E-Var {};
            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 1::2::3::[], x = 1, y = 2::3::[] |- 1 + length y evalto 3 by E-Plus {
                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 1::2::3::[], x = 1, y = 2::3::[] |- 1 evalto 1 by E-Int {};
                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 1::2::3::[], x = 1, y = 2::3::[] |- length y evalto 2 by E-AppRec {
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 1::2::3::[], x = 1, y = 2::3::[] |- length evalto ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] by E-Var {};
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 1::2::3::[], x = 1, y = 2::3::[] |- y evalto 2::3::[] by E-Var {};
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 2::3::[] |- match l with [] -> 0 | x :: y -> 1 + length y evalto 2 by E-MatchCons {
                        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 2::3::[] |- l evalto 2::3::[] by E-Var {};
                        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 2::3::[], x = 2, y = 3::[] |- 1 + length y evalto 2 by E-Plus {
                            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 2::3::[], x = 2, y = 3::[] |- 1 evalto 1 by E-Int {};
                            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 2::3::[], x = 2, y = 3::[] |- length y evalto 1 by E-AppRec{
                                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 2::3::[], x = 2, y = 3::[] |- length evalto ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] by E-Var {};
                                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 2::3::[], x = 2, y = 3::[] |- y evalto 3::[] by E-Var {};
                                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 3::[] |- match l with [] -> 0 | x :: y -> 1 + length y evalto 1 by E-MatchCons {
                                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 3::[] |- l evalto 3::[] by E-Var {};
                                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 3::[], x = 3, y = [] |- 1 + length y evalto 1 by E-Plus {
                                        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 3::[], x = 3, y = [] |- 1 evalto 1 by E-Int {};
                                        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 3::[], x = 3, y = [] |- length y evalto 0 by E-AppRec {
                                            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 3::[], x = 3, y = [] |- length evalto ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] by E-Var {};
                                            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = 3::[], x = 3, y = [] |- y evalto [] by E-Var {};
                                            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = [] |- match l with [] -> 0 | x :: y -> 1 + length y evalto 0 by E-MatchNil {
                                                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = [] |- l evalto [] by E-Var {};
                                                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = [] |- 0 evalto 0 by E-Int {}
                                            }
                                        };
                                        1 plus 0 is 1 by B-Plus {}
                                    }
                                }
                            };
                            1 plus 1 is 2 by B-Plus {}
                        }
                    }
                };
                1 plus 2 is 3 by B-Plus {}
            }
        }
    }
}

/*74*/length同样是在计算list的长度，但是这次是计算list中有多少个子list。
|- let rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y in length ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []) evalto 2 by E-LetRec {
     length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- length ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []) evalto 2 by E-AppRec {
        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- length evalto ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] by E-Var {};
        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []) evalto ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []) by E-Cons {
            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- (1 :: 2 :: [])  evalto (1 :: 2 :: []) by E-Cons {
                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 1 evalto 1 by E-Int {};
                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 2::[] evalto 2::[] by E-Cons {
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 2 evalto 2 by E-Int {};
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- [] evalto [] by E-Nil {}
                }
            };
            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- (3 :: 4 :: 5 :: []) :: [] evalto (3 :: 4 :: 5 :: []) :: [] by E-Cons {
                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- (3 :: 4 :: 5 :: []) evalto (3 :: 4 :: 5 :: []) by E-Cons {
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 3 evalto 3 by E-Int {};
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 4::5::[] evalto 4::5::[] by E-Cons {
                        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 4 evalto 4 by E-Int {};
                        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 5::[] evalto 5::[] by E-Cons {
                            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- 5 evalto 5 by E-Int {};
                            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- [] evalto [] by E-Nil {}
                        }
                    }
                };
                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] |- [] evalto [] by E-Nil {}
            }
        };
        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []) |- match l with [] -> 0 | x :: y -> 1 + length y evalto 2 by E-MatchCons {
            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []) |- l evalto ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []) by E-Var {};
            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []), x = 1::2::[], y = (3::4::5::[])::[] |- 1 + length y evalto 2 by E-Plus {
                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []), x = 1::2::[], y = (3::4::5::[])::[] |- 1 evalto 1 by E-Int {};
                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []), x = 1::2::[], y = (3::4::5::[])::[] |- length y evalto 1 by E-AppRec {
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []), x = 1::2::[], y = (3::4::5::[])::[] |- length evalto ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] by E-Var {};
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = ((1 :: 2 :: []) :: (3 :: 4 :: 5 :: []) :: []), x = 1::2::[], y = (3::4::5::[])::[] |- y evalto (3::4::5::[])::[] by E-Var {};
                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = (3::4::5::[])::[] |- match l with [] -> 0 | x :: y -> 1 + length y evalto 1 by E-MatchCons {
                        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = (3::4::5::[])::[] |- l evalto (3::4::5::[])::[] by E-Var {};
                        length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = (3::4::5::[])::[], x = (3::4::5::[]), y = [] |- 1 + length y evalto 1 by E-Plus {
                            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = (3::4::5::[])::[], x = (3::4::5::[]), y = [] |- 1 evalto 1 by E-Int {};
                            length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = (3::4::5::[])::[], x = (3::4::5::[]), y = [] |- length y evalto 0 by E-AppRec {
                                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = (3::4::5::[])::[], x = (3::4::5::[]), y = [] |- length evalto ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y] by E-Var {};
                                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = (3::4::5::[])::[], x = (3::4::5::[]), y = [] |- y evalto [] by E-Var {};
                                length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = [] |- match l with [] -> 0 | x :: y -> 1 + length y evalto 0 by E-MatchNil {
                                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = [] |- l evalto [] by E-Var {};
                                    length = ()[rec length = fun l -> match l with [] -> 0 | x :: y -> 1 + length y], l = [] |- 0 evalto 0 by E-Int {}
                                }
                            };
                            1 plus 0 is 1 by B-Plus {}
                        }
                    }
                };
                1 plus 1 is 2 by B-Plus {}
            }
        }
    }
}

/*75*/ append函数是将list合并。第一层的l1是(1 :: 2 :: []) ；l2是(3 :: 4 :: 5 :: [])。l1在match以后 1::  y再调用append函数。
|- let rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2 in append (1 :: 2 :: []) (3 :: 4 :: 5 :: []) evalto 1 :: 2 :: 3 :: 4 :: 5 :: [] by E-LetRec {
    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- append (1 :: 2 :: []) (3 :: 4 :: 5 :: []) evalto 1::2::3::4::5::[] by E-App {
        append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- append (1::2::[]) evalto (append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = (1::2::[]))[fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] by E-AppRec {
            append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- append evalto ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] by E-Var {};
            append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- (1::2::[]) evalto (1::2::[]) by E-Cons {
                append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- 1 evalto 1 by E-Int {};
                append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- 2::[] evalto 2::[] by E-Cons {
                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- 2 evalto 2 by E-Int {};
                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- [] evalto [] by E-Nil {};
                }
            };
            append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 1::2::[] |- fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2 evalto (append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = (1::2::[]))[fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] by E-Fun {}
        };
        append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- 3::4::5::[] evalto 3::4::5::[] by E-Cons {
            append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- 3 evalto 3 by E-Int {};
            append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- 4::5::[] evalto 4::5::[] by E-Cons {
                append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- 4 evalto 4 by E-Int {};
                append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- 5::[] evalto 5::[] by E-Cons {
                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- 5 evalto 5 by E-Int {};
                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] |- [] evalto [] by E-Nil {};
                }
            }
        }; 
        append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 1::2::[], l2 = 3::4::5::[] |- match l1 with [] -> l2 | x :: y -> x :: append y l2 evalto 1::2::3::4::5::[] by E-MatchCons {
            append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 1::2::[], l2 = 3::4::5::[] |- l1 evalto 1::2::[] by E-Var {};
            append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 1::2::[], l2 = 3::4::5::[], x = 1, y = 2::[] |- x :: append y l2 evalto 1::2::3::4::5::[] by E-Cons {
                append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 1::2::[], l2 = 3::4::5::[], x = 1, y = 2::[] |- x evalto 1 by E-Var {};
                append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 1::2::[], l2 = 3::4::5::[], x = 1, y = 2::[] |- append y l2 evalto 2::3::4::5::[] by E-App {
                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 1::2::[], l2 = 3::4::5::[], x = 1, y = 2::[] |- append y evalto (append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = (2::[]))[fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] by E-AppRec {
                        append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 1::2::[], l2 = 3::4::5::[], x = 1, y = 2::[] |- append evalto ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] by E-Var {};
                        append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 1::2::[], l2 = 3::4::5::[], x = 1, y = 2::[] |- y evalto 2::[] by E-Var {};
                        append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 2::[] |- fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2 evalto (append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = (2::[]))[fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] by E-Fun {};
                    };
                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 1::2::[], l2 = 3::4::5::[], x = 1, y = 2::[] |- l2 evalto 3::4::5::[] by E-Var {};
                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 2::[], l2 = 3::4::5::[] |- match l1 with [] -> l2 | x :: y -> x :: append y l2 evalto 2::3::4::5::[] by E-MatchCons {
                        append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 2::[], l2 = 3::4::5::[] |- l1 evalto 2::[] by E-Var {};
                        append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 2::[], l2 = 3::4::5::[], x = 2, y =[] |- x :: append y l2 evalto 2::3::4::5::[] by E-Cons {
                            append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 2::[], l2 = 3::4::5::[], x = 2, y =[] |- x evalto 2 by E-Var {};
                            append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 2::[], l2 = 3::4::5::[], x = 2, y =[] |- append y l2 evalto 3::4::5::[] by E-App {
                                append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 2::[], l2 = 3::4::5::[], x = 2, y =[] |- append y evalto (append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = [])[fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] by E-AppRec {
                                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 2::[], l2 = 3::4::5::[], x = 2, y =[] |- append evalto ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] by E-Var {};
                                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 2::[], l2 = 3::4::5::[], x = 2, y =[] |- y evalto [] by E-Var {};
                                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = [] |- fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2 evalto (append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = [])[fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2] by E-Fun {};
                                };
                                append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = 2::[], l2 = 3::4::5::[], x = 2, y =[] |- l2 evalto 3::4::5::[] by E-Var {};
                                append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = [], l2 = 3::4::5::[] |- match l1 with [] -> l2 | x :: y -> x :: append y l2 evalto 3::4::5::[] by E-MatchNil {
                                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = [], l2 = 3::4::5::[] |- l1 evalto [] by E-Var {};
                                    append = ()[rec append = fun l1 -> fun l2 -> match l1 with [] -> l2 | x :: y -> x :: append y l2], l1 = [], l2 = 3::4::5::[] |- l2 evalto 3::4::5::[] by E-Var {}
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/*76*/ apply函数比较复杂，首先需要解开结构：
第一层：
    l是((fun x -> x * x) :: (fun y -> y + 3) :: [])
    x是4
第二层：
    第一层的l中的f是(fun x -> x * x)
    这层的l是(fun y -> y + 3) :: []
第三层：第二次调用apply函数
    l是(fun y -> y + 3) :: []
    这时候f是(fun y -> y + 3)   l是[]
    当l是空的时候，函数apply会返回x，也就是4
返回第三层的f，4+3=7
返回第二层的f，7*7=49

|- let rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x) in apply ((fun x -> x * x) :: (fun y -> y + 3) :: []) 4 evalto 49 by E-LetRec {
    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] |- apply ((fun x -> x * x) :: (fun y -> y + 3) :: []) 4 evalto 49 by E-App {
        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] |- apply ((fun x -> x * x) :: (fun y -> y + 3) :: []) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []))[fun x -> match l with [] -> x | f :: l -> f (apply l x)] by E-AppRec {
            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] |- apply evalto ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] by E-Var {};
            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] |- ((fun x -> x * x) :: (fun y -> y + 3) :: []) evalto ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []) by E-Cons {
                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] |- (fun x -> x * x) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] by E-Fun {};
                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] |- (fun y -> y + 3) :: [] evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] by E-Cons {
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] |- (fun y -> y + 3) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] by E-Fun {};
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] |- [] evalto [] by E-Nil {};
                }
            };
            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []) |- fun x -> match l with [] -> x | f :: l -> f (apply l x) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []))[fun x -> match l with [] -> x | f :: l -> f (apply l x)] by E-Fun {};
        };
        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] |- 4 evalto 4 by E-Int {};
        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []), x = 4 |- match l with [] -> x | f :: l -> f (apply l x) evalto 49 by E-MatchCons {
            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []), x = 4 |- l evalto ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []) by E-Var {};
            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []), x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] |- f (apply l x) evalto 49 by E-App {
                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []), x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] |- f evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] by E-Var {};
                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []), x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] |- apply l x evalto 7 by E-App {
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []), x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] |- apply l evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [])[fun x -> match l with [] -> x | f :: l -> f (apply l x)] by E-AppRec {
                        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []), x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] |- apply evalto ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] by E-Var {};
                        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []), x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] |- l evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] by E-Var {};
                        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] |- fun x -> match l with [] -> x | f :: l -> f (apply l x) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [])[fun x -> match l with [] -> x | f :: l -> f (apply l x)] by E-Fun {};
                    };
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = ((apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: []), x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] |- x evalto 4 by E-Var {};
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [], x = 4 |- match l with [] -> x | f :: l -> f (apply l x) evalto 7 by E-MatchCons {
                        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [], x = 4 |- l evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [] by E-Var {};
                        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3], l = [] |- f (apply l x) evalto 7 by E-App {
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3], l = [] |- f evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] by E-Var {};
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3], l = [] |- apply l x evalto 4 by E-App {
                                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3], l = [] |- apply l evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = [])[fun x -> match l with [] -> x | f :: l -> f (apply l x)] by E-AppRec {
                                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3], l = [] |- apply evalto ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)] by E-Var {};
                                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3], l = [] |- l evalto [] by E-Var {};
                                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = [] |- fun x -> match l with [] -> x | f :: l -> f (apply l x) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = [])[fun x -> match l with [] -> x | f :: l -> f (apply l x)] by E-Fun {};
                                };
                                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)])[fun y -> y + 3], l = [] |- x evalto 4 by E-Var {};
                                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = [], x = 4 |- match l with [] -> x | f :: l -> f (apply l x) evalto 4 by E-MatchNil {
                                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = [], x = 4 |- l evalto [] by E-Var {};
                                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], l = [], x = 4 |- x evalto 4 by E-Var {};
                                }
                            };
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], y = 4 |- y + 3 evalto 7 by E-Plus {
                                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], y = 4 |- y evalto 4 by E-Var {};
                                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], y = 4 |- 3 evalto 3 by E-Int {};
                                4 plus 3 is 7 by B-Plus {};
                            }
                        }
                    }
                };
                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], x = 7 |- x * x evalto 49 by E-Times {
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], x = 7 |- x  evalto 7 by E-Var {};
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> f (apply l x)], x = 7 |- x  evalto 7 by E-Var {};
                    7 times 7 is 49 by B-Times {}
                }
            }
        }
    }
}

/*77*/E-App要处理两个部分：第一部分处理函数各层的关系，第二部分处理计算，这部分是将第一部分导入到环境变量中的函数E-Var出来，进行计算。
|- let rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x) in apply ((fun x -> x * x) :: (fun y -> y + 3) :: []) 4 evalto 19 by E-LetRec {
    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] |- apply ((fun x -> x * x) :: (fun y -> y + 3) :: []) 4 evalto 19 by E-App {
        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] |- apply ((fun x -> x * x) :: (fun y -> y + 3) :: []) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [])[fun x -> match l with [] -> x | f :: l -> apply l (f x)] by E-AppRec {
            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] |- apply evalto ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] by E-Var {};
            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] |- (fun x -> x * x) :: (fun y -> y + 3) :: [] evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] by E-Cons {
                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] |- (fun x -> x * x) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] by E-Fun {};
                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] |- (fun y -> y + 3) :: [] evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] by E-Cons {
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] |- (fun y -> y + 3) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] by E-Fun {};
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] |- [] evalto [] by E-Nil {};
                }
            };
            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] |- fun x -> match l with [] -> x | f :: l -> apply l (f x) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [])[fun x -> match l with [] -> x | f :: l -> apply l (f x)] by E-Fun {}
        };
        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] |- 4 evalto 4 by E-Int {};
        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 4 |- match l with [] -> x | f :: l -> apply l (f x) evalto 19 by E-MatchCons {
            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 4 |- l evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] by E-Var {};
            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] |- apply l (f x) evalto 19 by E-App {
                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] |- apply l evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [])[fun x -> match l with [] -> x | f :: l -> apply l (f x)] by E-AppRec {
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] |- apply evalto ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] by E-Var {};
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] |- l evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] by E-Var {};
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] |- fun x -> match l with [] -> x | f :: l -> apply l (f x) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [])[fun x -> match l with [] -> x | f :: l -> apply l (f x)] by E-Fun {}
                };
                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] |- f x evalto 16 by E-App {
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] |- f evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] by E-Var {};
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x] :: (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 4, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun x -> x * x], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] |- x evalto 4 by E-Var {};
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], x = 4 |- x * x evalto 16 by E-Times {
                        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], x = 4 |- x evalto 4 by E-Var {};
                        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], x = 4 |- x evalto 4 by E-Var {};
                        4 times 4 is 16 by B-Times {}
                    }
                };
                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 16 |- match l with [] -> x | f :: l -> apply l (f x) evalto 19 by E-MatchCons {
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 16 |- l evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [] by E-Var {};
                    apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 16, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3], l = [] |- apply l (f x) evalto 19 by E-App {
                        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 16, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3], l = [] |- apply l evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = [])[fun x -> match l with [] -> x | f :: l -> apply l (f x)] by E-AppRec {
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 16, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3], l = [] |- apply evalto ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)] by E-Var {};
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 16, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3], l = [] |- l evalto [] by E-Var {};
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = [] |- fun x -> match l with [] -> x | f :: l -> apply l (f x) evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = [])[fun x -> match l with [] -> x | f :: l -> apply l (f x)] by E-Fun {}
                        };
                        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 16, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3], l = [] |- f x evalto 19 by E-App {
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 16, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3], l = [] |- f evalto (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] by E-Var {};
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3] :: [], x = 16, f = (apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)])[fun y -> y + 3], l = [] |- x evalto 16 by E-Var {};
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], y = 16 |- y + 3 evalto 19 by E-Plus {
                                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], y = 16 |- y evalto 16 by E-Var {};
                                apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], y = 16 |- 3 evalto 3 by E-Int {};
                                16 plus 3 is 19 by B-Plus {}
                            }
                        };
                        apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = [], x = 19 |- match l with [] -> x | f :: l -> apply l (f x) evalto 19 by E-MatchNil {
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = [], x = 19 |- l evalto [] by E-Var {};
                            apply = ()[rec apply = fun l -> fun x -> match l with [] -> x | f :: l -> apply l (f x)], l = [], x = 19 |- x evalto 19 by E-Var {};
                        }
                    }
                }
            }
        }
    }
} 


/*78*/ 找到int list中的最大值，每次一个match只对比最前面两个值对比。

|- let rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z) in max (9 :: 2 :: 3 :: []) evalto 9 by E-LetRec {
    max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] |- max (9::2::3::[]) evalto 9 by E-AppRec {
        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] |- max evalto ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] by E-Var {};
        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] |- (9::2::3::[]) evalto (9::2::3::[]) by E-Cons {
            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] |- 9 evalto 9 by E-Int {};
            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] |- (2::3::[]) evalto (2::3::[]) by E-Cons {
                max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] |- 2 evalto 2 by E-Int {};
                max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] |- (3::[]) evalto (3::[]) by E-Cons {
                    max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] |- 3 evalto 3 by E-Int {};
                    max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] |- [] evalto [] by E-Nil {}
                }
            }
        };
        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]) |- match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z) evalto 9 by E-MatchN {
            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]) |- l evalto (9::2::3::[]) by E-Var {};
            x::[] doesn't match (9::2::3::[]) by NM-ConsConsR {
                [] doesn't match 2::3::[] by NM-ConsNil {}
            };
            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]) |- match l with x::y::z -> if x < y then max (y :: z) else max (x :: z) evalto 9 by E-MatchM1 {
                max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]) |- l evalto 9::2::3::[] by E-Var {};
                x::y::z matches 9::2::3::[] when (x = 9, y = 2, z = 3::[]) by M-Cons {
                    x matches 9 when (x = 9) by M-Var {};
                    y::z matches 2::3::[] when (y = 2, z = 3::[]) by M-Cons {
                        y matches 2 when (y = 2) by M-Var {};
                        z matches 3::[] when (z = 3::[]) by M-Var {}
                    }
                };
                max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]), x = 9, y = 2, z = 3::[] |- if x < y then max (y :: z) else max (x :: z) evalto 9 by E-IfF {
                    max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]), x = 9, y = 2, z = 3::[] |- x < y evalto false by E-Lt {
                        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]), x = 9, y = 2, z = 3::[] |- x evalto 9 by E-Var {};
                        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]), x = 9, y = 2, z = 3::[] |- y evalto 2 by E-Var {};
                        9 less than 2 is false by B-Lt {}
                    };
                    max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]), x = 9, y = 2, z = 3::[] |- max (x::z) evalto 9 by E-AppRec {
                        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]), x = 9, y = 2, z = 3::[] |- max evalto ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] by E-Var {};
                        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]), x = 9, y = 2, z = 3::[] |- x::z evalto 9::3::[] by E-Cons {
                            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]), x = 9, y = 2, z = 3::[] |- x evalto 9 by E-Var {};
                            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = (9::2::3::[]), x = 9, y = 2, z = 3::[] |- z evalto 3::[] by E-Var {}
                        };
                        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[] |- match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z) evalto 9 by E-MatchN {
                            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[] |- l evalto 9::3::[] by E-Var {};
                            x::[] doesn't match 9::3::[] by NM-ConsConsR {
                                [] doesn't match 3::[] by NM-ConsNil {}
                            };
                            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[] |- match l with x :: y :: z -> if x < y then max (y :: z) else max (x :: z) evalto 9 by E-MatchM1 {
                                max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[] |- l evalto 9::3::[] by E-Var {};
                                x::y::z matches 9::3::[] when (x = 9, y = 3, z = []) by M-Cons {
                                    x matches 9 when (x = 9) by M-Var {};
                                    y::z matches 3::[] when (y = 3, z = []) by M-Cons {
                                        y matches 3 when (y = 3) by M-Var {};
                                        z matches [] when (z = []) by M-Var {}
                                    }
                                };
                                max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[], x = 9, y = 3, z = [] |- if x < y then max (y :: z) else max (x :: z) evalto 9 by E-IfF {
                                    max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[], x = 9, y = 3, z = [] |- x < y evalto false by E-Lt {
                                        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[], x = 9, y = 3, z = [] |- x evalto 9 by E-Var {};
                                        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[], x = 9, y = 3, z = [] |- y evalto 3 by E-Var {};
                                        9 less than 3 is false by B-Lt {};
                                    };
                                    max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[], x = 9, y = 3, z = [] |- max (x::z) evalto 9 by E-AppRec {
                                        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[], x = 9, y = 3, z = [] |- max evalto ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)] by E-Var {}; 
                                        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[], x = 9, y = 3, z = [] |- x::z evalto 9::[] by E-Cons {
                                            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[], x = 9, y = 3, z = [] |- x evalto 9 by E-Var {};
                                            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::3::[], x = 9, y = 3, z = [] |- z evalto [] by E-Var {}
                                        };
                                        max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::[] |- match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z) evalto 9 by E-MatchM2 {
                                            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::[] |- l evalto 9::[] by E-Var {};
                                            x::[] matches 9::[] when (x = 9) by M-Cons {
                                                x matches 9 when (x = 9) by M-Var {};
                                                [] matches [] when () by M-Nil {}
                                            };
                                            max = ()[rec max = fun l -> match l with x :: [] -> x | x :: y :: z -> if x < y then max (y :: z) else max (x :: z)], l = 9::[], x = 9|- x evalto 9 by E-Var {}
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}




/*79*/ 
首先，这个match有三种情况，分别用｜隔开，_ 使用M-wild导出，代表任意的表达式。
function heads的意思是，把每一段的头找出来。如果list全是用空，那么头为空｜如果list前面有空，那么跳过，直到最开始的字符｜取出头字符。
第一次匹配，前面两个match都要MatchN跳过去。第三个match将第一段的1取出来。
第二次匹配，首先需要用match2第二个条件跳过一个空，然后也要用MatchN跳过两次，然后将3取出来。
第三次匹配，直接匹配的到一个match2，取出一个空。

需要注意的是：本题的变量有很多次的变换，每次环境中变量的变换是在apprec的时候，原来的环境需要变换为新的环境。

|- let rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l' in heads ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) evalto 1 :: 3 :: [] by E-LetRec {
    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- heads ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) evalto 1::3::[] by E-AppRec {
        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- heads  evalto ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] by E-Var {};
        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) evalto ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) by E-Cons {
            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- (1 :: 2 :: [])  evalto (1 :: 2 :: []) by E-Cons {
                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- 1 evalto 1 by E-Int {};
                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- 2 :: []  evalto 2 :: [] by E-Cons {
                    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- 2 evalto 2 by E-Int {};
                    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- []  evalto [] by E-Nil {}
                }
            };
            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- [] :: (3 :: []) :: [] evalto [] :: (3 :: []) :: [] by E-Cons {
                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- [] evalto [] by E-Nil {};
                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- (3 :: []) :: [] evalto (3 :: []) :: [] by E-Cons {
                    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- (3 :: []) evalto (3 :: []) by E-Cons {
                        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- 3 evalto 3 by E-Int {};
                        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- [] evalto [] by E-Nil {}
                    };
                    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] |- [] evalto [] by E-Nil {}
                }
            }
        };
        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) |- match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l' evalto 1::3::[] by E-MatchN {
            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) |- l evalto ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) by E-Var {};
            [] doesn't match ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) by NM-ConsNil {};
            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) |- match l with [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l' evalto 1::3::[] by E-MatchN {
                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) |- l evalto ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) by E-Var {};
                [] :: l' doesn't match ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) by NM-ConsConsL {
                    [] doesn't match (1::2::[]) by NM-ConsNil {};
                };
                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) |- match l with (x :: _) :: l' -> x :: heads l' evalto 1::3::[] by E-MatchM1 {
                    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) |- l evalto ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) by E-Var {};
                    (x :: _) :: l' matches ((1 :: 2 :: []) :: [] :: (3 :: []) :: []) when (x = 1, l' = []::(3::[])::[]) by M-Cons {
                        (x :: _) matches (1 :: 2 :: [])  when (x = 1) by M-Cons {
                            x matches 1 when (x = 1) by M-Var {};
                            _ matches 2::[] when () by M-Wild {}
                        };
                        l' matches [] :: (3 :: []) :: [] when (l' = [] :: (3 :: []) :: []) by M-Var {}
                    };
                    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []), x = 1, l' = []::(3::[])::[] |- x :: heads l' evalto 1::3::[] by E-Cons {
                        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []), x = 1, l' = []::(3::[])::[] |- x evalto 1 by E-Var {};
                        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []), x = 1, l' = []::(3::[])::[] |- heads l' evalto 3::[] by E-AppRec {
                            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []), x = 1, l' = []::(3::[])::[] |- heads evalto ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] by E-Var {};
                            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ((1 :: 2 :: []) :: [] :: (3 :: []) :: []), x = 1, l' = []::(3::[])::[] |- l' evalto []::(3::[])::[] by E-Var {};
                            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ([] :: (3 :: []) :: []) |- match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l' evalto 3::[] by E-MatchN {
                                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ([] :: (3 :: []) :: []) |- l evalto ([] :: (3 :: []) :: []) by E-Var {};
                                [] doesn't match ([] :: (3 :: []) :: []) by NM-ConsNil {};
                                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ([] :: (3 :: []) :: []) |- match l with [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l' evalto 3::[] by E-MatchM2 {
                                    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ([] :: (3 :: []) :: []) |- l evalto ([] :: (3 :: []) :: []) by E-Var {};
                                    []::l' matches []::(3::[])::[] when (l' = (3::[])::[]) by M-Cons {
                                        [] matches [] when () by M-Nil {};
                                        l' matches (3::[])::[] when (l' = (3::[])::[]) by M-Var {}
                                    };
                                    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ([] :: (3 :: []) :: []), l' = (3::[])::[] |- heads l' evalto 3::[] by E-AppRec {
                                        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ([] :: (3 :: []) :: []), l' = (3::[])::[] |- heads evalto ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] by E-Var {};
                                        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = ([] :: (3 :: []) :: []), l' = (3::[])::[] |- l' evalto (3::[])::[] by E-Var {};
                                        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [] |- match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l' evalto 3::[] by E-MatchN {
                                            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [] |- l evalto (3::[])::[] by E-Var {};
                                            [] doesn't match (3::[])::[] by NM-ConsNil {};
                                            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [] |- match l with [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l' evalto 3::[] by E-MatchN {
                                                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [] |- l evalto (3::[])::[] by E-Var {};
                                                []::l' doesn't match (3::[])::[] by NM-ConsConsL {
                                                    [] doesn't match 3::[] by NM-ConsNil {};
                                                };
                                                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [] |- match l with (x :: _) :: l' -> x :: heads l' evalto 3::[] by E-MatchM1 {
                                                    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [] |- l evalto (3::[])::[] by E-Var {};
                                                    (x::_)::l' matches (3::[])::[] when (x = 3, l' = []) by M-Cons {
                                                        x::_ matches 3::[] when (x = 3) by M-Cons {
                                                            x matches 3 when (x = 3) by M-Var {};
                                                            _ matches [] when () by M-Wild {};
                                                        };
                                                        l' matches [] when (l' = []) by M-Var {}
                                                    };
                                                    heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [], x = 3, l' = [] |- x :: heads l' evalto 3::[] by E-Cons {
                                                        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [], x = 3, l' = [] |- x evalto 3 by E-Var {};
                                                        heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [], x = 3, l' = [] |- heads l' evalto [] by E-AppRec {
                                                            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [], x = 3, l' = [] |- heads evalto ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'] by E-Var {};
                                                            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = (3 :: []) :: [], x = 3, l' = [] |- l' evalto [] by E-Var {};
                                                            heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = [] |- match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l' evalto [] by E-MatchM2 {
                                                                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = [] |- l evalto [] by E-Var {};
                                                                [] matches [] when () by M-Nil {};
                                                                heads = ()[rec heads = fun l -> match l with [] -> [] | [] :: l' -> heads l' | (x :: _) :: l' -> x :: heads l'], l = [] |- [] evalto [] by E-Nil {}
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
